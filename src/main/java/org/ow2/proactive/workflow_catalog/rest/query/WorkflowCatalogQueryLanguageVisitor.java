/*
 *  ProActive Parallel Suite(TM): The Java(TM) library for
 *     Parallel, Distributed, Multi-Core Computing for
 *     Enterprise Grids & Clouds
 *
 *  Copyright (C) 1997-2016 INRIA/University of
 *                  Nice-Sophia Antipolis/ActiveEon
 *  Contact: proactive@ow2.org or contact@activeeon.com
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Affero General Public License
 *  as published by the Free Software Foundation; version 3 of
 *  the License.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
 *  USA
 *
 *  If needed, contact us to obtain a release under GPL Version 2 or 3
 *  or a different license than the AGPL.
 *
 *  Initial developer(s):               The ProActive Team
 *                          http://proactive.inria.fr/team_members.htm
 */
package org.ow2.proactive.workflow_catalog.rest.query;

import com.google.common.collect.ImmutableMap;
import com.mysema.query.BooleanBuilder;
import com.mysema.query.types.Predicate;
import org.ow2.proactive.workflow_catalog.rest.entity.QGenericInformation;
import org.ow2.proactive.workflow_catalog.rest.entity.QVariable;
import org.ow2.proactive.workflow_catalog.rest.entity.QWorkflowRevision;
import org.ow2.proactive.workflow_catalog.rest.query.parser.WorkflowCatalogQueryLanguageBaseVisitor;
import org.ow2.proactive.workflow_catalog.rest.query.parser.WorkflowCatalogQueryLanguageParser;

import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * The concrete visitor that will create the predicate based
 * on the AST generated by {@link WorkflowCatalogQueryCompiler}
 *
 * @author ActiveEon Team
 */
public class WorkflowCatalogQueryLanguageVisitor extends WorkflowCatalogQueryLanguageBaseVisitor<BooleanBuilder> {

    private final static String NEQ = "!=";
    private final static String EQ = "=";
    private final static String VAR_TOKEN = "variable";
    private final static String GI_TOKEN = "generic_information";
    private final static String NAME_TOKEN = "name";
    private final static String PROJ_TOKEN = "project_name";
    private final static String NAME_KEYWORD = "name";
    private final static String VALUE_KEYWORD = "value";
    private static final Map<ClauseKey, Function<String, Predicate>> clausesToFuncMap;

    static {
        clausesToFuncMap = initClausesToFuncMap();
    }

    @Override
    public BooleanBuilder visitExpression(WorkflowCatalogQueryLanguageParser.ExpressionContext ctx) {
        return visitAnd_expression(ctx.and_expression());
    }

    @Override
    public BooleanBuilder visitAnd_expression(WorkflowCatalogQueryLanguageParser.And_expressionContext ctx) {
        BooleanBuilder booleanBuilder = new BooleanBuilder();
        for (WorkflowCatalogQueryLanguageParser.Or_expressionContext orExpressionContext : ctx.or_expression()) {
            booleanBuilder.and(visit(orExpressionContext));
        }
        return booleanBuilder;
    }

    @Override
    public BooleanBuilder visitOr_expression(WorkflowCatalogQueryLanguageParser.Or_expressionContext ctx) {
        BooleanBuilder booleanBuilder = new BooleanBuilder();
        for (WorkflowCatalogQueryLanguageParser.ClauseContext clauseContext : ctx.clause()) {
            booleanBuilder.or(visit(clauseContext));
        }
        return booleanBuilder;
    }

    public BooleanBuilder visitFinalClause(WorkflowCatalogQueryLanguageParser.FinalClauseContext ctx) {

        String attributeLiteral = ctx.AttributeLiteral().getText();
        String stringLiteral = ctx.StringLiteral().getText();

        // a String literal always starts and ends by a " character
        // remove leading and trailing " character
        stringLiteral = stringLiteral.substring(1, stringLiteral.length() - 1);

        BooleanBuilder booleanBuilder = new BooleanBuilder();

        ClauseKey.TABLE table = getTable(attributeLiteral);
        ClauseKey.OPERATION operation = getOperation(ctx.COMPARE_OPERATOR().getText());
        ClauseKey.CLAUSE_TYPE clauseType = getClauseType(attributeLiteral);
        Pattern wildcardPattern = Pattern.compile(".*[^\\\\]%.*");
        Matcher wildcardMatcher = wildcardPattern.matcher(attributeLiteral);
        boolean hasWildcards = wildcardMatcher.matches();
        ClauseKey clauseKey = new ClauseKey(table, operation, clauseType, hasWildcards);
        Function<String, Predicate> predicateCreator = clausesToFuncMap.get(clauseKey);

        if (predicateCreator == null) {
            throw new QueryPredicateBuilderRuntimeException("No predicate found for clause " + clauseKey);
        }

        return booleanBuilder.and(predicateCreator.apply(stringLiteral));
    }

    public BooleanBuilder visitParenthesedClause(WorkflowCatalogQueryLanguageParser.ParenthesedClauseContext ctx) {
        return visitAnd_expression(ctx.and_expression());
    }

    protected ClauseKey.TABLE getTable(String attributeName) {
        String[] terms = attributeName.split(Pattern.quote("."));
        if (terms.length > 1) {
            if (terms[0].equalsIgnoreCase(VAR_TOKEN)) {
                return ClauseKey.TABLE.VARIABLE;
            }
            else if (terms[0].equalsIgnoreCase(GI_TOKEN)) {
                return ClauseKey.TABLE.GENERIC_INFORMATION;
            }
        }
        else {
            if (terms[0].equalsIgnoreCase(NAME_TOKEN)) {
                return ClauseKey.TABLE.NAME;
            }
            else if (terms[0].equalsIgnoreCase(PROJ_TOKEN)) {
                return ClauseKey.TABLE.PROJECT_NAME;
            }
        }
        throw new QueryPredicateBuilderRuntimeException("Table name found in " + attributeName + " is invalid");
    }

    protected ClauseKey.OPERATION getOperation(String operation) {
        if (operation.contentEquals(EQ)) {
            return ClauseKey.OPERATION.EQUAL;
        }
        else if (operation.contentEquals(NEQ)) {
            return ClauseKey.OPERATION.NOT_EQUAL;
        }
        else {
            throw new QueryPredicateBuilderRuntimeException("operation " + operation + " is invalid");
        }
    }

    protected ClauseKey.CLAUSE_TYPE getClauseType(String attributeLiteral) {
        ClauseKey.TABLE table = getTable(attributeLiteral);
        if (table == ClauseKey.TABLE.VARIABLE || table == ClauseKey.TABLE.GENERIC_INFORMATION) {
            String[] terms = attributeLiteral.split(Pattern.quote("."));
            assert terms.length > 1;
            if (terms[1].equalsIgnoreCase(NAME_KEYWORD)) {
                return ClauseKey.CLAUSE_TYPE.KEY;
            }
            else if (terms[1].equalsIgnoreCase(VALUE_KEYWORD)) {
                return ClauseKey.CLAUSE_TYPE.VALUE;
            }
            else {
                throw new QueryPredicateBuilderRuntimeException("Clause type found in " + attributeLiteral + " is invalid");
            }
        }
        else if (table == ClauseKey.TABLE.NAME || table == ClauseKey.TABLE.PROJECT_NAME) {
            return ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE;
        }
        else {
            throw new QueryPredicateBuilderRuntimeException("Clause " + attributeLiteral + " is invalid");
        }
    }

    private static Map<ClauseKey, Function<String, Predicate>> initClausesToFuncMap() {
        Map<ClauseKey, Function<String, Predicate>> map = new HashMap<>(32);

        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.KEY, false),
                literalString -> QVariable.variable.key.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.KEY, false),
                literalString -> QVariable.variable.key.ne(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.VALUE, false),
                literalString -> QVariable.variable.value.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.VALUE, false),
                literalString -> QVariable.variable.value.ne(literalString));

        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.KEY, false),
                literalString -> QGenericInformation.genericInformation.key.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.KEY, false),
                literalString -> QGenericInformation.genericInformation.key.ne(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.VALUE, false),
                literalString -> QGenericInformation.genericInformation.value.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.VALUE, false),
                literalString -> QGenericInformation.genericInformation.value.ne(literalString));

        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, false),
                literalString -> QWorkflowRevision.workflowRevision.name.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, false),
                literalString -> QWorkflowRevision.workflowRevision.name.ne(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, false),
                literalString -> QWorkflowRevision.workflowRevision.name.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, false),
                literalString -> QWorkflowRevision.workflowRevision.name.ne(literalString));

        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, false),
                literalString -> QWorkflowRevision.workflowRevision.projectName.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, false),
                literalString -> QWorkflowRevision.workflowRevision.projectName.ne(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, false),
                literalString -> QWorkflowRevision.workflowRevision.projectName.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, false),
                literalString -> QWorkflowRevision.workflowRevision.projectName.ne(literalString));

        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.KEY, true),
                literalString -> QVariable.variable.key.like(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.KEY, true),
                literalString -> QVariable.variable.key.notLike(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.VALUE, true),
                literalString -> QVariable.variable.value.like(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.VALUE, true),
                literalString -> QVariable.variable.value.notLike(literalString));

        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.KEY, true),
                literalString -> QGenericInformation.genericInformation.key.like(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.KEY, true),
                literalString -> QGenericInformation.genericInformation.key.notLike(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.VALUE, true),
                literalString -> QGenericInformation.genericInformation.value.like(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.VALUE, true),
                literalString -> QGenericInformation.genericInformation.value.notLike(literalString));

        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, true),
                literalString -> QWorkflowRevision.workflowRevision.name.like(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, true),
                literalString -> QWorkflowRevision.workflowRevision.name.notLike(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, true),
                literalString -> QWorkflowRevision.workflowRevision.name.like(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, true),
                literalString -> QWorkflowRevision.workflowRevision.name.notLike(literalString));

        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, true),
                literalString -> QWorkflowRevision.workflowRevision.projectName.like(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, true),
                literalString -> QWorkflowRevision.workflowRevision.projectName.notLike(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, true),
                literalString -> QWorkflowRevision.workflowRevision.projectName.like(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, true),
                literalString -> QWorkflowRevision.workflowRevision.projectName.notLike(literalString));

        return ImmutableMap.copyOf(map);
    }

}
