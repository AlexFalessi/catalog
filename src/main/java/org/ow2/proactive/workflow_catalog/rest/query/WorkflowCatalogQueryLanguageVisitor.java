package org.ow2.proactive.workflow_catalog.rest.query;

import com.google.common.collect.ImmutableMap;
import com.mysema.query.BooleanBuilder;
import com.mysema.query.types.Predicate;
import org.ow2.proactive.workflow_catalog.rest.entity.QGenericInformation;
import org.ow2.proactive.workflow_catalog.rest.entity.QVariable;
import org.ow2.proactive.workflow_catalog.rest.entity.QWorkflowRevision;
import org.ow2.proactive.workflow_catalog.rest.query.parser.WorkflowCatalogQueryLanguageBaseVisitor;
import org.ow2.proactive.workflow_catalog.rest.query.parser.WorkflowCatalogQueryLanguageParser;

import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;
import java.util.regex.Pattern;

/**
 * The concrete visitor that will create the predicate based
 * on the AST generated by {@link WorkflowCatalogQueryCompiler}
 *
 * @author ActiveEon Team
 */
public class WorkflowCatalogQueryLanguageVisitor extends WorkflowCatalogQueryLanguageBaseVisitor<BooleanBuilder> {

    private final static String NEQ = "!=";
    private final static String EQ = "=";
    private final static String VAR_TOKEN = "variable";
    private final static String GI_TOKEN = "generic_information";
    private final static String NAME_TOKEN = "name";
    private final static String PROJ_TOKEN = "project_name";
    private final static String NAME_KEYWORD = "name";
    private final static String VALUE_KEYWORD = "value";
    private static final Map<ClauseKey, Function<String, Predicate>> clausesToFuncMap;

    static {
        clausesToFuncMap = initClausesToFuncMap();
    }

    @Override
    public BooleanBuilder visitExpression(WorkflowCatalogQueryLanguageParser.ExpressionContext ctx) {
        return visitAnd_expression(ctx.and_expression());
    }

    @Override
    public BooleanBuilder visitAnd_expression(WorkflowCatalogQueryLanguageParser.And_expressionContext ctx) {
        BooleanBuilder booleanBuilder = new BooleanBuilder();
        for (WorkflowCatalogQueryLanguageParser.Or_expressionContext orExpressionContext : ctx.or_expression()) {
            booleanBuilder.and(visit(orExpressionContext));
        }
        return booleanBuilder;
    }

    @Override
    public BooleanBuilder visitOr_expression(WorkflowCatalogQueryLanguageParser.Or_expressionContext ctx) {
        BooleanBuilder booleanBuilder = new BooleanBuilder();
        for (WorkflowCatalogQueryLanguageParser.ClauseContext clauseContext : ctx.clause()) {
            booleanBuilder.or(visit(clauseContext));
        }
        return booleanBuilder;
    }

    public BooleanBuilder visitFinalClause(WorkflowCatalogQueryLanguageParser.FinalClauseContext ctx) {

        String attributeLiteral = ctx.AttributeLiteral().getText();
        String stringLiteral = ctx.StringLiteral().getText();
        BooleanBuilder booleanBuilder = new BooleanBuilder();

        ClauseKey.TABLE table = getTable(attributeLiteral);
        ClauseKey.OPERATION operation = getOperation(ctx.COMPARE_OPERATOR().getText());
        ClauseKey.CLAUSE_TYPE clauseType = getClauseType(attributeLiteral);
        ClauseKey clauseKey = new ClauseKey(table, operation, clauseType);
        Function<String, Predicate> predicateCreator = clausesToFuncMap.get(clauseKey);

        if (predicateCreator == null) {
            throw new QueryBuilderException("No predicate found for clause " + clauseKey);
        }

        return booleanBuilder.and(predicateCreator.apply(stringLiteral));
    }

    public BooleanBuilder visitParenthesedClause(WorkflowCatalogQueryLanguageParser.ParenthesedClauseContext ctx) {
        return visitAnd_expression(ctx.and_expression());
    }

    private ClauseKey.TABLE getTable(String attributeName) {
        if (attributeName.contains(VAR_TOKEN + ".")) {
            return ClauseKey.TABLE.VARIABLE;
        }
        else if (attributeName.contains(GI_TOKEN + ".")) {
            return ClauseKey.TABLE.GENERIC_INFORMATION;
        }
        else if (attributeName.contains(NAME_TOKEN)) {
            return ClauseKey.TABLE.NAME;
        }
        else if (attributeName.contains(PROJ_TOKEN)) {
            return ClauseKey.TABLE.PROJECT_NAME;
        }
        else {
            throw new QueryBuilderException("Attribute name " + attributeName + " is invalid");
        }
    }

    private ClauseKey.OPERATION getOperation(String operation) {
        if (operation.contentEquals(EQ)) {
            return ClauseKey.OPERATION.EQUAL;
        }
        else if (operation.contentEquals(NEQ)) {
            return ClauseKey.OPERATION.NOT_EQUAL;
        }
        else {
            throw new QueryBuilderException("operation " + operation + " is invalid");
        }
    }

    private ClauseKey.CLAUSE_TYPE getClauseType(String attributeLiteral) {
        ClauseKey.TABLE table = getTable(attributeLiteral);
        if (table == ClauseKey.TABLE.VARIABLE || table == ClauseKey.TABLE.GENERIC_INFORMATION) {
            String[] terms = attributeLiteral.split(Pattern.quote("."));
            assert terms.length > 1;
            if (terms[1].equalsIgnoreCase(NAME_KEYWORD)) {
                return ClauseKey.CLAUSE_TYPE.KEY;
            }
            else if (terms[1].equalsIgnoreCase(VALUE_KEYWORD)) {
                return ClauseKey.CLAUSE_TYPE.VALUE;
            }
            else {
                throw new QueryBuilderException("Clause type found in " + attributeLiteral + " is invalid");
            }
        }
        else if (table == ClauseKey.TABLE.NAME || table == ClauseKey.TABLE.PROJECT_NAME) {
            return ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE;
        }
        else {
            throw new QueryBuilderException("Clause " + attributeLiteral + " is invalid");
        }
    }

    private static Map<ClauseKey, Function<String, Predicate>> initClausesToFuncMap() {
        Map<ClauseKey, Function<String, Predicate>> map = new HashMap<>(16);

        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.KEY),
                literalString -> QVariable.variable.key.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.KEY),
                literalString -> QVariable.variable.key.ne(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.VALUE),
                literalString -> QVariable.variable.value.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.VALUE),
                literalString -> QVariable.variable.value.ne(literalString));

        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.KEY),
                literalString -> QGenericInformation.genericInformation.key.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.KEY),
                literalString -> QGenericInformation.genericInformation.key.ne(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.VALUE),
                literalString -> QGenericInformation.genericInformation.value.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.VALUE),
                literalString -> QGenericInformation.genericInformation.value.ne(literalString));

        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE),
                literalString -> QWorkflowRevision.workflowRevision.name.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE),
                literalString -> QWorkflowRevision.workflowRevision.name.ne(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE),
                literalString -> QWorkflowRevision.workflowRevision.name.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE),
                literalString -> QWorkflowRevision.workflowRevision.name.ne(literalString));

        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE),
                literalString -> QWorkflowRevision.workflowRevision.projectName.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE),
                literalString -> QWorkflowRevision.workflowRevision.projectName.ne(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE),
                literalString -> QWorkflowRevision.workflowRevision.projectName.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE),
                literalString -> QWorkflowRevision.workflowRevision.projectName.ne(literalString));

        return ImmutableMap.copyOf(map);
    }

}
