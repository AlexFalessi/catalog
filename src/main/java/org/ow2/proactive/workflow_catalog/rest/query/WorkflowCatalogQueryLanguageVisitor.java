/*
 *  ProActive Parallel Suite(TM): The Java(TM) library for
 *     Parallel, Distributed, Multi-Core Computing for
 *     Enterprise Grids & Clouds
 *
 *  Copyright (C) 1997-2016 INRIA/University of
 *                  Nice-Sophia Antipolis/ActiveEon
 *  Contact: proactive@ow2.org or contact@activeeon.com
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Affero General Public License
 *  as published by the Free Software Foundation; version 3 of
 *  the License.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
 *  USA
 *
 *  If needed, contact us to obtain a release under GPL Version 2 or 3
 *  or a different license than the AGPL.
 *
 *  Initial developer(s):               The ProActive Team
 *                          http://proactive.inria.fr/team_members.htm
 */
package org.ow2.proactive.workflow_catalog.rest.query;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.ow2.proactive.workflow_catalog.rest.entity.QGenericInformation;
import org.ow2.proactive.workflow_catalog.rest.entity.QVariable;
import org.ow2.proactive.workflow_catalog.rest.entity.QWorkflowRevision;
import org.ow2.proactive.workflow_catalog.rest.query.parser.WorkflowCatalogQueryLanguageBaseVisitor;
import org.ow2.proactive.workflow_catalog.rest.query.parser.WorkflowCatalogQueryLanguageParser;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Sets;
import com.mysema.query.BooleanBuilder;
import com.mysema.query.types.Predicate;
import com.mysema.query.types.path.EntityPathBase;

/**
 * The concrete visitor that will create the predicate based
 * on the AST generated by {@link WorkflowCatalogQueryCompiler}
 *
 * @author ActiveEon Team
 */
public class WorkflowCatalogQueryLanguageVisitor extends WorkflowCatalogQueryLanguageBaseVisitor<BooleanBuilder> {

    private final static String NEQ = "!=";
    private final static String EQ = "=";
    private final static String VAR_TOKEN = "variable";
    private final static String GI_TOKEN = "generic_information";
    private final static String NAME_TOKEN = "name";
    private final static String PROJ_TOKEN = "project_name";
    private final static String NAME_KEYWORD = "name";
    private final static String VALUE_KEYWORD = "value";

    private final Map<ClauseKey, Function<String, Predicate>> clausesToFuncMap;

    private final QGenerator generator;

    public WorkflowCatalogQueryLanguageVisitor() {
        clausesToFuncMap = initClausesToFuncMap();
        generator = new QGenerator();
    }

    @Override
    public BooleanBuilder visitExpression(WorkflowCatalogQueryLanguageParser.ExpressionContext ctx) {
        return visitOr_expression(ctx.or_expression());
    }

    @Override
    public BooleanBuilder visitAnd_expression(WorkflowCatalogQueryLanguageParser.And_expressionContext ctx) {
        BooleanBuilder booleanBuilder = new BooleanBuilder();
        for (WorkflowCatalogQueryLanguageParser.ClauseContext clauseContext : ctx.clause()) {
            booleanBuilder.and(visit(clauseContext));
        }
        return booleanBuilder;
    }

    @Override
    public BooleanBuilder visitOr_expression(WorkflowCatalogQueryLanguageParser.Or_expressionContext ctx) {
        BooleanBuilder booleanBuilder = new BooleanBuilder();
        for (WorkflowCatalogQueryLanguageParser.And_expressionContext andExpressionContext : ctx.and_expression()) {
            booleanBuilder.or(visit(andExpressionContext));
        }
        return booleanBuilder;
    }

    public BooleanBuilder visitFinalClause(WorkflowCatalogQueryLanguageParser.FinalClauseContext ctx) {

        String attributeLiteral = ctx.AttributeLiteral().getText();
        String stringLiteral = ctx.StringLiteral().getText();

        // a String literal always starts and ends by a " character
        // remove leading and trailing " character
        stringLiteral = stringLiteral.substring(1, stringLiteral.length() - 1);

        BooleanBuilder booleanBuilder = new BooleanBuilder();

        ClauseKey.TABLE table = getTable(attributeLiteral);
        ClauseKey.OPERATION operation = getOperation(ctx.COMPARE_OPERATOR().getText());
        ClauseKey.CLAUSE_TYPE clauseType = getClauseType(attributeLiteral);

        Pattern wildcardPattern = Pattern.compile(".*[^\\\\]%.*");
        Matcher wildcardMatcher = wildcardPattern.matcher(stringLiteral);
        boolean hasWildcards = wildcardMatcher.matches();
        ClauseKey clauseKey = new ClauseKey(table, operation, clauseType, hasWildcards);
        Function<String, Predicate> predicateCreator = clausesToFuncMap.get(clauseKey);

        if (predicateCreator == null) {
            throw new QueryPredicateBuilderRuntimeException("No predicate found for clause '" + clauseKey + "'");
        }

        return booleanBuilder.and(predicateCreator.apply(stringLiteral));
    }

    public BooleanBuilder visitParenthesedClause(WorkflowCatalogQueryLanguageParser.ParenthesedClauseContext ctx) {
        return visitOr_expression(ctx.or_expression());
    }

    protected ClauseKey.TABLE getTable(String attributeName) {
        String[] terms = attributeName.split(Pattern.quote("."));

        if (terms.length > 1) {
            if (terms[0].equalsIgnoreCase(VAR_TOKEN)) {
                return ClauseKey.TABLE.VARIABLE;
            }
            else if (terms[0].equalsIgnoreCase(GI_TOKEN)) {
                return ClauseKey.TABLE.GENERIC_INFORMATION;
            }
        }
        else {
            if (terms[0].equalsIgnoreCase(NAME_TOKEN)) {
                return ClauseKey.TABLE.NAME;
            }
            else if (terms[0].equalsIgnoreCase(PROJ_TOKEN)) {
                return ClauseKey.TABLE.PROJECT_NAME;
            }
        }

        throw new QueryPredicateBuilderRuntimeException("Invalid attribute name '" + attributeName + "'");
    }

    protected ClauseKey.OPERATION getOperation(String operation) {
        if (operation.contentEquals(EQ)) {
            return ClauseKey.OPERATION.EQUAL;
        }
        else if (operation.contentEquals(NEQ)) {
            return ClauseKey.OPERATION.NOT_EQUAL;
        } else {
            throw new QueryPredicateBuilderRuntimeException("Operator '" + operation + "' is invalid");
        }
    }

    protected ClauseKey.CLAUSE_TYPE getClauseType(String attributeLiteral) {
        ClauseKey.TABLE table = getTable(attributeLiteral);
        if (table == ClauseKey.TABLE.VARIABLE || table == ClauseKey.TABLE.GENERIC_INFORMATION) {
            String[] terms = attributeLiteral.split(Pattern.quote("."));
            assert terms.length > 1;
            if (terms[1].equalsIgnoreCase(NAME_KEYWORD)) {
                return ClauseKey.CLAUSE_TYPE.KEY;
            }
            else if (terms[1].equalsIgnoreCase(VALUE_KEYWORD)) {
                return ClauseKey.CLAUSE_TYPE.VALUE;
            }
	    else {
                throw new QueryPredicateBuilderRuntimeException("Clause type found in '" + attributeLiteral + "' is invalid");
            }
        }
	else if (table == ClauseKey.TABLE.NAME || table == ClauseKey.TABLE.PROJECT_NAME) {
            return ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE;
        }
        else {
            throw new QueryPredicateBuilderRuntimeException("Clause '" + attributeLiteral + "' is invalid");
        }
    }

    public QGenerator getGenerator() {
        return generator;
    }

    private Map<ClauseKey, Function<String, Predicate>> initClausesToFuncMap() {
        Map<ClauseKey, Function<String, Predicate>> map = new HashMap<>(32);

        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.KEY, false),
                literalString -> generator.createVariableAlias().key.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.KEY, false),
                literalString -> generator.createVariableAlias().key.ne(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.VALUE, false),
                literalString -> generator.createVariableAlias().value.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.VALUE, false),
                literalString -> generator.createVariableAlias().value.ne(literalString));

        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.KEY, false),
                literalString -> generator.createGenericInformationAlias().key.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.KEY, false),
                literalString -> generator.createGenericInformationAlias().key.ne(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.VALUE, false),
                literalString -> generator.createGenericInformationAlias().value.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.VALUE, false),
                literalString -> generator.createGenericInformationAlias().value.ne(literalString));

        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, false),
                literalString -> QWorkflowRevision.workflowRevision.name.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, false),
                literalString -> QWorkflowRevision.workflowRevision.name.ne(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, false),
                literalString -> QWorkflowRevision.workflowRevision.name.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, false),
                literalString -> QWorkflowRevision.workflowRevision.name.ne(literalString));

        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, false),
                literalString -> QWorkflowRevision.workflowRevision.projectName.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, false),
                literalString -> QWorkflowRevision.workflowRevision.projectName.ne(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, false),
                literalString -> QWorkflowRevision.workflowRevision.projectName.eq(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, false),
                literalString -> QWorkflowRevision.workflowRevision.projectName.ne(literalString));

        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.KEY, true),
                literalString -> generator.createVariableAlias().key.like(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.KEY, true),
                literalString -> generator.createVariableAlias().key.notLike(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.VALUE, true),
                literalString -> generator.createVariableAlias().value.like(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.VARIABLE, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.VALUE, true),
                literalString -> generator.createVariableAlias().value.notLike(literalString));

        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.KEY, true),
                literalString -> generator.createGenericInformationAlias().key.like(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.KEY, true),
                literalString -> generator.createGenericInformationAlias().key.notLike(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.VALUE, true),
                literalString -> generator.createGenericInformationAlias().value.like(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.GENERIC_INFORMATION, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.VALUE, true),
                literalString -> generator.createGenericInformationAlias().value.notLike(literalString));

        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, true),
                literalString -> QWorkflowRevision.workflowRevision.name.like(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, true),
                literalString -> QWorkflowRevision.workflowRevision.name.notLike(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, true),
                literalString -> QWorkflowRevision.workflowRevision.name.like(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, true),
                literalString -> QWorkflowRevision.workflowRevision.name.notLike(literalString));

        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, true),
                literalString -> QWorkflowRevision.workflowRevision.projectName.like(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, true),
                literalString -> QWorkflowRevision.workflowRevision.projectName.notLike(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, true),
                literalString -> QWorkflowRevision.workflowRevision.projectName.like(literalString));
        map.put(new ClauseKey(ClauseKey.TABLE.PROJECT_NAME, ClauseKey.OPERATION.NOT_EQUAL, ClauseKey.CLAUSE_TYPE.NOT_APPLICABLE, true),
                literalString -> QWorkflowRevision.workflowRevision.projectName.notLike(literalString));

        return ImmutableMap.copyOf(map);
    }

    /**
     * The purpose of QGenerator is to ensure that each clause for
     * a given attribute has a unique alias name.
     */
    public static class QGenerator {

        private int index = 0;

        private final Set<QGenericInformation> qGenericInformation = Sets.newHashSet();

        private final Set<QVariable> qVariables = Sets.newHashSet();

        public QGenericInformation createGenericInformationAlias() {
            return (QGenericInformation) createAlias("genericInformation", aliasName -> {
                    QGenericInformation alias = new QGenericInformation(aliasName);
                    qGenericInformation.add(alias);
                    return alias;
            });
        }

        public QVariable createVariableAlias() {
            return (QVariable) createAlias("variable", aliasName -> {
                QVariable alias = new QVariable(aliasName);
                qVariables.add(alias);
                return alias;
            });
        }

        public EntityPathBase<?> createAlias(String aliasPrefix, Function<String, EntityPathBase<?>> function) {
            EntityPathBase<?> result = function.apply(aliasPrefix + index);
            index++;
            return result;
        }

        public Set<QGenericInformation> getGenericInformationAliases() {
            return qGenericInformation;
        }

        public Set<QVariable> getVariableAliases() {
            return qVariables;
        }

    }

}
